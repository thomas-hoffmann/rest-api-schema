{
	"info": {
		"_postman_id": "f4959b4d-22cf-4a36-b3d8-799c296b7945",
		"name": "Functional Testing v2.0",
		"description": "This functional test suite validates the core behavior of the API endpoints to ensure they meet specified business requirements and operate reliably under expected conditions. It focuses on verifying the correctness of API responses for valid and invalid inputs across common use cases.\n\n### Scope of Tests\n\nThe suite covers the following test categories:\n\n- **Response Status Codes**\n    \n    Verifies that the correct HTTP status codes (e.g., 200, 400, 401, 404, 500) are returned according to the request context.\n    \n- **Payload Validation**\n    \n    Ensures the structure and data types of the response payload match the expected schema using assertions (e.g., `pm.expect()` for property presence and types).\n    \n- **Business Logic Verification**\n    \n    Tests functional rules such as pagination, item limits, filtering mechanisms, and mandatory field enforcement.\n    \n- **Error Handling**\n    \n    Confirms that meaningful error responses, including proper codes and descriptive messages, are returned for invalid requests or missing data.\n    \n- **Boundary Condition Testing**\n    \n    Validates system behavior under edge conditions like empty responses or maximum input limits.\n    \n\nThis suite is intended for CI/CD integration and supports environment-specific testing (e.g., development, staging) via Postman environments and variable configurations. Each test case is stateless and idempotent, ensuring consistent results across repeated executions.\n\n## Setup Instructions\n\n### Collection Configuration\n\n- **Collection Variables**\n    \n    Store common configuration valuesâ€”such as base URLs and auth tokensâ€”at the collection level to enable reuse and centralized management.\n    \n- **Environment Requirements**\n    \n    A Postman environment must be selected before execution. This environment supplies dynamic values like environment-specific URLs and credentials.\n    \n- **Collection-Level Pre-request Scripts**\n    \n    Define global setup logic (e.g., timestamp generation, authentication headers) that executes before each request for consistent initialization.\n    \n- **Folder-Level Pre-request Scripts**\n    \n    Use folder-scoped scripts for modular setup logic such as test data creation, parameter configuration, or group-specific headers.\n    \n- **Automated Functional Assertions**\n    \n    Each request includes tests to validate HTTP status codes, response payload structure, and headers.\n    \n\n**Note:** Ensure a valid environment is selected and all necessary variables are properly configured prior to running the test suite.\n\n## Database\n\nWe are using the [Sommer Demo DB](https://jtlgmbh-my.sharepoint.com/:u:/g/personal/thomas_hoffmann_jtl-software_com/EU9qR4VW0YBDqRfcTQgkv_sBlr5Q0OZp7SMxhVkYOiZaVw?e=RFqxqn) (around 300 MB) for the functional tests.\n\nEnsure that you have installed the database and register the app in this DB.\n\nUse the app registration data (app-sersion, app-id, api-key) to build your own environment.\n\n## Creating a New Environment\n\nCreate a new Postman environment with the following key-value pairs:\n\n| Key | Description |\n| --- | --- |\n| `tenantName` | Your database name (e.g., `eazybusiness, mandant_1, ...`) |\n| `apiKey` | The API key from your app registration |\n| `appID` | The App ID from your app registration |\n| `appVersion` | The version of your registered app |\n| `runAsUser` | User ID to execute as (default: `1`) |\n| `baseURL` | Base URL of your REST API instance (default: `http://localhost:5883`) |\n| `authorizationValue` | Use the format `Wawi {{apiKey}}` (no backticks) |\n| `expectedMaxAmountOfCustomers` | The expected number of customers in your database |\n| `expectedMaxAmountOfArticles` | The expected number of articles in your database |\n\nðŸ’¡ **Hint:** You can duplicate an existing environment and update the values as needed. Donâ€™t forget to rename the copied environment to avoid confusion.\n\n## Script Details\n\n### Pre-request Script\n\nThis script sets required headers for each request, such as:\n\n- `x-apiVersion`\n    \n- `x-AppId`\n    \n- _(and other custom headers)_\n    \n\nIt also checks if all required variables (environment, collection) are setup-ed.\n\n### Test (Post-request) Script\n\nThe post-request script provides reusable helper functions to:\n\n- Validate the success response schema\n    \n- Check for expected status codes (success and error)\n    \n- Inspect the structure of error responses\n    \n- Utility methods, such as:\n    \n    - Extracting query parameters\n        \n\nðŸ§¾ To explore these functions, click the `Scripts` tab in Postman and review the inline documentation provided.\n\n## Contribute\n\nFollow the instruction of the [how to contribute](https://confluence.jtl-software.de/spaces/~THoffmann/pages/273687352/How+to+contribute) documentation.",
		"schema": "https://schema.getpostman.com/json/collection/v2.0.0/collection.json"
	},
	"item": [],
	"auth": {
		"type": "apikey",
		"apikey": {
			"value": "{{env-authorizationValue}}",
			"key": "Authorization"
		}
	},
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"id": "20bca202-0b99-42d9-99f3-d1bee49eba84",
				"type": "text/javascript",
				"packages": {},
				"requests": {},
				"exec": [
					"\r",
					"resolveApiKey();\r",
					"resolveAppId();\r",
					"resolveChallengeCode()\r",
					"\r",
					"// We set the needed header value depending supported api version of the collection\r",
					"// The api version is stored in the collection variables\r",
					"pm.request.headers.upsert({ key: 'api-version', value: pm.collectionVariables.get('col-apiVersion') });\r",
					"\r",
					"pm.request.headers.upsert({ key: 'x-challengecode', value: pm.collectionVariables.get('col-challengecode') });\r",
					"// x-AppID\r",
					"pm.request.headers.upsert({ key: 'x-AppID', value: pm.environment.get('env-appId') });\r",
					"// x-AppVersion\r",
					"pm.request.headers.upsert({ key: 'x-AppVersion', value: pm.environment.get('env-appVersion') });\r",
					"// x-api-key\r",
					"pm.request.headers.upsert({ key: 'x-api-key', value: pm.environment.get('env-apiKey') });\r",
					"// tenant-id\r",
					"pm.request.headers.upsert({ key: 'x-tenant-id', value: pm.environment.get('env-tenant-id') });\r",
					"\r",
					"function resolveApiKey() {\r",
					"    var apiKey = pm.environment.get('env-apiKey-system.all');\r",
					"    var isSystemRead = isScopeSystemRead()\r",
					"    if (isSystemRead) {\r",
					"        apiKey = pm.environment.get('env-apiKey-system.read');\r",
					"    }\r",
					"    pm.environment.set('env-apiKey', apiKey);\r",
					"}\r",
					"\r",
					"function resolveAppId() {\r",
					"    var appId = pm.environment.get('env-appId-system.all');\r",
					"    console.log(pm.info.requestName)\r",
					"    var isSystemRead = isScopeSystemRead()\r",
					"    if (isSystemRead) {\r",
					"        appId = pm.environment.get('env-appId-system.read');\r",
					"    }\r",
					"    pm.environment.set('env-appId', appId);\r",
					"}\r",
					"\r",
					"\r",
					"function resolveChallengeCode() {\r",
					"    const headerChallengeCode = pm.request.headers.get(\"x-challengecode\")\r",
					"    console.log(\"Found\" + headerChallengeCode)\r",
					"    let challengeCode = null;\r",
					"    if (headerChallengeCode) {\r",
					"        console.log(\"found challengecode in header\")\r",
					"        challengeCode = headerChallengeCode\r",
					"    } else {\r",
					"        challengeCode = pm.variables.replaceIn('{{$guid}}');\r",
					"    }\r",
					"\r",
					"    pm.collectionVariables.set('col-challengecode', challengeCode)    \r",
					"}\r",
					"\r",
					"function isScopeSystemRead() {\r",
					"    return pm.info.requestName.match(/NonAdmin|System\\.Read|SystemRead/)\r",
					"}"
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"id": "abb21cf0-f505-4864-bd66-197ba2525bb8",
				"type": "text/javascript",
				"packages": {},
				"requests": {},
				"exec": [
					"// Utility/Helper functions for the current collection\r",
					"collectionUtils = {\r",
					"\r",
					"    /**\r",
					"     * Common methods for general collection-level checks.\r",
					"     */\r",
					"    common: {\r",
					"        /**\r",
					"         * Validates that the response code matches the expected HTTP status code.\r",
					"         *\r",
					"         * @function\r",
					"         * @param {Object} response - The Postman response object.\r",
					"         * @param {number} code - The expected HTTP response status code.\r",
					"         * \r",
					"         * @throws {AssertionError} HTTP status code must equal the expected code\r",
					"         * \r",
					"         * @example\r",
					"         * // Validate that the Response code has a specified number\r",
					"         * collectionUtils.common.validateResponseCode(pm.response, 200);\r",
					"         */\r",
					"        validateResponseCode: function (response, code) {\r",
					"            pm.expect(response.code).to.equal(code);\r",
					"        },\r",
					"\r",
					"        /**\r",
					"         * Validates the schema of an empty paginated API response.\r",
					"         *\r",
					"         * @function\r",
					"         * @param {Object} response - The Postman response object.\r",
					"         * \r",
					"         * @throws {AssertionError} Properties `TotalItems`, `Items`, `PageNumber`, etc., must match the expected empty schema values\r",
					"         * \r",
					"         * @example\r",
					"         * // Validate that the empty Response schema \r",
					"         * collectionUtils.common.validateEmptyResponseSchema(pm.response);\r",
					"         */\r",
					"        validateEmptyResponseSchema: function (response, thresholds = {}) {\r",
					"            const defaulThresholds = {\r",
					"                totalItems: 0,\r",
					"                pageNumber: 1,\r",
					"                pageSize: 100,\r",
					"                totalPages: 0,\r",
					"                hasPreviousPage: false,\r",
					"                hasNextPage: false,\r",
					"                nextPageNumber: 0,\r",
					"                previousPageNumber: 1\r",
					"            };\r",
					"            const mergedThresholds = { ...defaulThresholds, ...thresholds };\r",
					"            console.log(mergedThresholds)\r",
					"            const responseData = response.json();\r",
					"            pm.expect(responseData).to.be.an('object');\r",
					"            /*\r",
					"            pm.expect(responseData).to.have.property('TotalItems').that.is.a('number').and.is.eq(0, 'TotalItems');\r",
					"            pm.expect(responseData).to.have.property('PageNumber').that.is.a('number').and.is.eq(1, 'PageNumber');\r",
					"            pm.expect(responseData).to.have.property('PageNumber').that.is.a('number').and.is.eq(mergedThresholds.pageNumber, 'PageNumber');\r",
					"            pm.expect(responseData).to.have.property('PageSize').that.is.a('number').and.is.eq(100, 'PageSize');\r",
					"            pm.expect(responseData).to.have.property('Items').that.is.an('array').and.deep.equal([], 'Items');\r",
					"            pm.expect(responseData).to.have.property('TotalPages').that.is.a('number').and.is.eq(0, 'TotalPages');\r",
					"            pm.expect(responseData).to.have.property('HasPreviousPage').that.is.a('boolean').and.is.eq(false, 'HasPreviousPage');\r",
					"            pm.expect(responseData).to.have.property('HasNextPage').that.is.a('boolean').and.is.eq(false, 'HasNextPage');;\r",
					"            pm.expect(responseData).to.have.property('NextPageNumber').that.is.a('number').and.is.eq(0, 'NextPageNumber');\r",
					"            pm.expect(responseData).to.have.property('PreviousPageNumber').that.is.a('number').and.is.eq(1, 'PreviousPageNumber');\r",
					"            */\r",
					"            // pm.expect(responseData).to.have.property('TotalItems').that.is.a('number').and.is.greaterThanOrEqual(mergedThresholds.totalItems, 'TotalItems');\r",
					"            /* pm.expect(responseData).to.have.property('PageNumber').that.is.a('number').and.is.eq(mergedThresholds.pageNumber, 'PageNumber');\r",
					"            pm.expect(responseData).to.have.property('PageSize').that.is.a('number').and.is.eq(mergedThresholds.pageSize, 'PageSize');\r",
					"            pm.expect(responseData).to.have.property('Items').that.is.an('array').and.to.be.empty\r",
					"            pm.expect(responseData).to.have.property('TotalPages').and.is.eq(mergedThresholds.totalPages, 'TotalPages');\r",
					"            pm.expect(responseData).to.have.property('HasPreviousPage').that.is.a('boolean').and.is.eq(mergedThresholds.hasPreviousPage, 'HasPreviousPage');\r",
					"            // pm.expect(responseData).to.have.property('HasNextPage').that.is.a('boolean').and.is.eq(mergedThresholds.hasNextPage, 'HasNextPage');\r",
					"            // TODO: fix \r",
					"            // pm.expect(responseData).to.have.property('NextPageNumber').that.is.a('number').and.is.eq(mergedThresholds.nextPageNumber, 'NextPageNumber');\r",
					"            pm.expect(responseData).to.have.property('PreviousPageNumber').that.is.a('number').and.is.eq(mergedThresholds.previousPageNumber, 'PreviousPageNumber');\r",
					"            */\r",
					"        },\r",
					"\r",
					"        /**\r",
					"         * Validates the schema of a paginated API response with optional threshold overrides.\r",
					"         *\r",
					"         * @function\r",
					"         * @param {Object} response - The Postman response object.\r",
					"         * @param {Object} thresholds - Optional threshold values to override default pagination expectations.\r",
					"         * \r",
					"         * @throws {AssertionError} Schema properties must meet default or custom threshold values\r",
					"         * \r",
					"         * @example\r",
					"         * // Basic validation of the Response schema \r",
					"         * collectionUtils.common.validateResponseSchema(pm.response);\r",
					"         * @example\r",
					"         * // Validate that the Response schema has given pagination information\r",
					"         * collectionUtils.common.validateResponseSchema(pm.response, { totalItems: 50, hasNextPage: false });\r",
					"         */\r",
					"        validateResponseSchema: function (response, thresholds = {}) {\r",
					"            const defaulThresholds = {\r",
					"                totalItems: 123,\r",
					"                pageNumber: 1,\r",
					"                pageSize: 100,\r",
					"                totalPages: 1,\r",
					"                hasPreviousPage: false,\r",
					"                hasNextPage: true,\r",
					"                nextPageNumber: 2,\r",
					"                previousPageNumber: 1\r",
					"            };\r",
					"            const mergedThresholds = { ...defaulThresholds, ...thresholds };\r",
					"            const responseData = response.json();\r",
					"            pm.expect(responseData).to.be.an('object');\r",
					"            pm.expect(responseData).to.have.property('TotalItems').that.is.a('number').and.is.greaterThanOrEqual(mergedThresholds.totalItems, 'TotalItems');\r",
					"            pm.expect(responseData).to.have.property('PageNumber').that.is.a('number').and.is.eq(mergedThresholds.pageNumber, 'PageNumber');\r",
					"            pm.expect(responseData).to.have.property('PageSize').that.is.a('number').and.is.eq(mergedThresholds.pageSize, 'PageSize');\r",
					"            pm.expect(responseData).to.have.property('Items').that.is.an('array').and.to.have.length.least(1, 'Items');\r",
					"            pm.expect(responseData).to.have.property('TotalPages').and.is.greaterThanOrEqual(mergedThresholds.totalPages, 'TotalPages');\r",
					"            pm.expect(responseData).to.have.property('HasPreviousPage').that.is.a('boolean').and.is.eq(mergedThresholds.hasPreviousPage, 'HasPreviousPage');\r",
					"            pm.expect(responseData).to.have.property('HasNextPage').that.is.a('boolean').and.is.eq(mergedThresholds.hasNextPage, 'HasNextPage');\r",
					"            // TODO: fix \r",
					"            // pm.expect(responseData).to.have.property('NextPageNumber').that.is.a('number').and.is.eq(mergedThresholds.nextPageNumber, 'NextPageNumber');\r",
					"            pm.expect(responseData).to.have.property('PreviousPageNumber').that.is.a('number').and.is.eq(mergedThresholds.previousPageNumber, 'PreviousPageNumber');\r",
					"        },\r",
					"    },\r",
					"    /**\r",
					"     * Functions for validating standard API error responses.\r",
					"     */\r",
					"    error: {\r",
					"        /**\r",
					"         * Validates that an error response contains all required error properties.\r",
					"         *\r",
					"         * @function\r",
					"         * @param {Object} response - The Postman response object (e.g., `pm.response`).\r",
					"         * \r",
					"         * @throws {AssertionError} `ErrorCode`, `ValidationErrors`, `ErrorMessage`, and `Stacktrace` must be present in the response body\r",
					"         * \r",
					"         * @example\r",
					"         * // Validate the error response schema \r",
					"         * collectionUtils.error.validateErrorResponseSchema(pm.response);\r",
					"         */\r",
					"        validateErrorResponseSchema: function (response) {\r",
					"            const responseData = response.json();\r",
					"            pm.expect(responseData).to.have.property(\"ErrorCode\");\r",
					"            pm.expect(responseData).to.have.property(\"ValidationErrors\");\r",
					"            pm.expect(responseData).to.have.property(\"ErrorMessage\");\r",
					"            pm.expect(responseData).to.have.property(\"Stacktrace\");\r",
					"        },\r",
					"\r",
					"        /**\r",
					"         * Validates that the error code in the response matches the expected value.\r",
					"         *\r",
					"         * @function\r",
					"         * @param {Object} response - The Postman response object (e.g., `pm.response`).\r",
					"         * @param {string} expectedValue - The expected error code to match.\r",
					"         * \r",
					"         * @throws {AssertionError} `ErrorCode` must be a string equal to the expected value\r",
					"         * \r",
					"         * @example\r",
					"         * // Validate that the ErrorCode property has a specified text\r",
					"         * collectionUtils.error.validateErrorCode(pm.response, \"ERR_401_UNAUTHORIZED\");\r",
					"         */\r",
					"        validateErrorCode: function (response, expectedValue) {\r",
					"            const responseData = response.json();\r",
					"            pm.expect(responseData.ErrorCode).that.is.a('string', 'ErrorCode').and.that.is.eql(expectedValue, 'ErrorCode');\r",
					"        },\r",
					"\r",
					"        /**\r",
					"         * Validates that the error message is either a specific string or null.\r",
					"         *\r",
					"         * @function\r",
					"         * @param {Object} response - The Postman response object.\r",
					"         * @param {string|null} expectedValue - Expected error message string or null.\r",
					"         * \r",
					"         * @throws {AssertionError} `ErrorMessage` must be a string or null, and match the expected value if provided\r",
					"         * \r",
					"         * @example\r",
					"         * // Validate that the ErrorMessage property has a specified text\r",
					"         * collectionUtils.error.validateErrorMessage(pm.response, \"Invalid input.\");\r",
					"         * @example\r",
					"         * // Basic validation of the ErrorMessage property\r",
					"         * collectionUtils.error.validateErrorMessage(pm.response);\r",
					"         */\r",
					"        validateErrorMessage: function (response, expectedValue) {\r",
					"            const responseData = response.json();            \r",
					"            pm.expect(responseData.ErrorMessage).to.be.a('string', 'ErrorMessage').and.that.is.eql(expectedValue, 'ErrorMessage');            \r",
					"        },\r",
					"\r",
					"        /**\r",
					"         * Validates that the stacktrace is either a specific string or does not exists.\r",
					"         *\r",
					"         * @function\r",
					"         * @param {Object} response - The Postman response object.\r",
					"         * @param {string|null} expectedValue - Expected stacktrace string or null.\r",
					"         * \r",
					"         * @throws {AssertionError} `Stacktrace` must be a string or null, and match the expected value if provided\r",
					"         * \r",
					"         * @example\r",
					"         * // Validate that the Stacktrace property has a specified text\r",
					"         * collectionUtils.error.validateStacktrace(pm.response, \"stacktrace details\");\r",
					"         * @example\r",
					"         * // Basic validation of the Stacktrace property\r",
					"         * collectionUtils.error.validateStacktrace(pm.response);\r",
					"         */\r",
					"        validateStacktrace: function (response, expectedValue) {\r",
					"            const responseData = response.json();\r",
					"            if (expectedValue) {\r",
					"                pm.expect(responseData).to.have.property('Stacktrace').that.is.a('string', 'Stacktrace').and.that.is.eql(expectedValue, 'Stacktrace');\r",
					"            } else {\r",
					"                pm.expect(responseData).to.have.property('Stacktrace', null, 'Response')\r",
					"            }\r",
					"        },\r",
					"\r",
					"        /**\r",
					"         * Validates a specific validation error exists with the expected value.\r",
					"         *\r",
					"         * @function\r",
					"         * @param {Object} response - The Postman response object.\r",
					"         * @param {string} expectedProperty - Property name expected in validation errors.\r",
					"         * @param {string} expectedValue - Expected value for the specified validation error property.\r",
					"         * \r",
					"         * @throws {AssertionError} `ValidationErrors` must contain the property with the correct value\r",
					"         * \r",
					"         * @example\r",
					"         * // Validate that the ValidationErrors object contains a property with a specified text\r",
					"         * collectionUtils.error.validateValidationError(pm.response, \"email\", \"Email is required\");\r",
					"         */\r",
					"        validateValidationError: function (response, expectedProperty, expectedValue) {\r",
					"            const responseData = response.json();\r",
					"            const propertyName = expectedProperty\r",
					"            pm.expect(responseData).to.have.property('ValidationErrors').that.is.a('object', 'ValidationErrors');\r",
					"\r",
					"            pm.expect(responseData.ValidationErrors).to.have.property(propertyName);\r",
					"            const propertyValue = responseData.ValidationErrors[propertyName];\r",
					"            pm.expect(propertyValue).that.is.a('string', `ValidationErrors.${expectedProperty}`).and.that.is.eq(expectedValue, `ValidationErrors.${expectedProperty}`);\r",
					"        },\r",
					"    }, \r",
					"\r",
					"    /**\r",
					"     * Helper methods for general collection-level checks.\r",
					"     */\r",
					"    helper: {\r",
					"\r",
					"        getLanguageIsoCodes: function () {\r",
					"            return ['DE', 'EN']\r",
					"        },\r",
					"\r",
					"        /**\r",
					"         * Returns the value of a query parameter from the request URL.\r",
					"         *\r",
					"         * @function\r",
					"         * @param {string} queryParam - Name of the parameter to extract from the URL.\r",
					"         * \r",
					"         * @example\r",
					"         * // Get the value of the query parameter pageSize\r",
					"         * const pageSize = collectionUtils.helper.getQueryParamValue(\"pageSize\");\r",
					"         */\r",
					"        getQueryParamValue: function (queryParam) {\r",
					"            const url = pm.request.url.toString();\r",
					"            const queryString = url.split('?')[1];\r",
					"            \r",
					"            if (!queryString) return null;\r",
					"\r",
					"            const params = queryString.split('&');\r",
					"            \r",
					"            for (let i = 0; i < params.length; i++) {\r",
					"                const [key, value] = params[i].split('=');               \r",
					"                if (decodeURIComponent(key) === queryParam) {\r",
					"                    return decodeURIComponent(value || '');\r",
					"                }\r",
					"            }\r",
					"\r",
					"            return null;\r",
					"        },\r",
					"\r",
					"        getDateTimeRegExp: function () {\r",
					"            return new RegExp(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}[+-]\\d{2}:\\d{2}$/)\r",
					"        },\r",
					"\r",
					"        setRandomPageNumber: function (maxPageNumber = 2) {\r",
					"            let randomNumber = Math.floor(Math.random() * maxPageNumber) + 1;\r",
					"\r",
					"            // Clear existing 'pageSize' param if it exists\r",
					"            pm.request.url.query.remove(function (param) {\r",
					"                return param.key === \"pageNumber\";\r",
					"            });\r",
					"\r",
					"            // Add the new 'pageSize' query param\r",
					"            pm.request.url.query.add({\r",
					"                key: \"pageNumber\",\r",
					"                value: randomNumber.toString()\r",
					"            });\r",
					"        },\r",
					"\r",
					"        setRandomPageSize: function (maxPageSize = 100) {\r",
					"            let randomNumber = Math.floor(Math.random() * maxPageSize) + 1;\r",
					"\r",
					"            // Clear existing 'pageSize' param if it exists\r",
					"            pm.request.url.query.remove(function (param) {\r",
					"                return param.key === \"pageSize\";\r",
					"            });\r",
					"\r",
					"            // Add the new 'pageSize' query param\r",
					"            pm.request.url.query.add({\r",
					"                key: \"pageSize\",\r",
					"                value: randomNumber.toString()\r",
					"            });\r",
					"        },\r",
					"\r",
					"        getTotalPages: function(totalItems, pageSize) {\r",
					"            const pageSizeDividedByTotalItems = Number(totalItems) / Number(pageSize)\r",
					"            return Number(totalItems) > Number(pageSize) ? Math.ceil( pageSizeDividedByTotalItems ) : 1\r",
					"        },\r",
					"\r",
					"        getNextPageNumber: function(totalPages) {\r",
					"            let pageNumber = this.getQueryParamValue('pageNumber')\r",
					"            if (!pageNumber) {\r",
					"                pageNumber = 1\r",
					"            } \r",
					"            return Number(pageNumber) < Number(totalPages) ? Number(pageNumber) + 1 : Number(totalPages)\r",
					"        },\r",
					"\r",
					"        getHasNextPage: function(nextPageNumber, totalPages) {\r",
					"            return Number(nextPageNumber) > Number(totalPages)\r",
					"        },\r",
					"\r",
					"        getHasPreviousPage: function(nextPageNumber) {\r",
					"            return nextPageNumber > 1\r",
					"        }\r",
					"    },\r",
					"};\r",
					"\r",
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "col-baseUrl",
			"value": "{{env-baseURL}}/api/{{env-tenant-id}}"
		},
		{
			"key": "col-apiVersion",
			"value": "2"
		},
		{
			"key": "col-expectedMaxAmountOfCustomers",
			"value": "110"
		},
		{
			"key": "col-expectedMaxAmountOfArticles",
			"value": "661"
		},
		{
			"key": "col-expectedMaxAmountOfCategories",
			"value": "178"
		},
		{
			"key": "col-challengecode",
			"value": ""
		}
	]
}